{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@covalent/experimental/http/http.mixin.ts","ng://@covalent/experimental/http/actions/params/abstract-param.decorator.ts","ng://@covalent/experimental/http/actions/methods/abstract-method.decorator.ts","ng://@covalent/experimental/http/actions/methods/get.decorator.ts","ng://@covalent/experimental/http/actions/methods/post.decorator.ts","ng://@covalent/experimental/http/actions/methods/patch.decorator.ts","ng://@covalent/experimental/http/actions/methods/put.decorator.ts","ng://@covalent/experimental/http/actions/methods/delete.decorator.ts","ng://@covalent/experimental/http/actions/class/http.decorator.ts","ng://@covalent/experimental/http/actions/params/param.decorator.ts","ng://@covalent/experimental/http/actions/params/body.decorator.ts","ng://@covalent/experimental/http/actions/params/response.decorator.ts","ng://@covalent/experimental/http/actions/params/query-params.decorator.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","__read","n","r","e","ar","push","error","NOOP_HTTP","of","undefined","mixinHttp","base","config","_super","class_1","tslib_1.__extends","defineProperty","basePath","replace","_baseUrl","buildConfig","http","_injector","get","httpServiceType","HttpClient","baseUrl","_baseHeaders","baseHeaders","HttpHeaders","_defaultObserve","defaultObserve","_defaultResponseType","defaultResponseType","buildHeaders","_this","headersObj","keys","forEach","key","buildRequest","method","url","options","_buildRequest","responseType","observe","headers","headers_1","set","HttpInterceptorService","Http","headers_2","Headers","params_1","URLSearchParams","params","HttpParams","observable","request","body","pipe","map","response","json","text","blob","arrayBuffer","Error","HttpInternalClass","apply","__spread","arguments","concat","injectArgs","types","injector","args","arg","isArray","type","flags","j","meta","Optional","ngMetadataName","SkipSelf","Self","Inject","token","ÉµReflectionCapabilities","parameters","Injectable","Injector","tdHttpRESTParam","TdAbstractParam","param","target","propertyKey","parameterIndex","Reflect","getOwnMetadata","index","defineMetadata","parseParams","source","queryParams","TdAbstractMethod","propertyName","descriptor","wrappedFunction","replacedPath","path","newArgs","parameters_1","tslib_1.__values","parameters_1_1","parameter","qParams","assign","parameters_2","parameters_2_1","console","GET","POST","PATCH","PUT","DELETE","TdHttp","TdParam","TdBody","TdResponse","TdQueryParams"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Type, Injectable, Injector, ÃÂµReflectionCapabilities, InjectFlags, Optional,\n  SkipSelf, Self, Inject, InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Http, Response, Headers, URLSearchParams } from '@angular/http';\nimport { HttpInterceptorService } from '@covalent/http';\n\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport type TdHttpMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE' | 'HEAD' | 'PUT' | 'OPTIONS';\n\nexport type TdHttpRESTResponseType = 'arraybuffer' | 'blob' | 'json' | 'text';\n\nexport type TdHttpRESTObserve = 'body' | 'response' | 'events';\n\nexport interface ITdHttpRESTConfig {\n  baseHeaders?: HttpHeaders;\n  baseUrl: string;\n  defaultObserve?: TdHttpRESTObserve;\n  defaultResponseType?: TdHttpRESTResponseType;\n  httpServiceType?: Type<Http | HttpClient | HttpInterceptorService>;\n}\n\nexport interface ITdHttpRESTOptions {\n  headers?: HttpHeaders | {\n    [header: string]: string | string[];\n  };\n  observe?: TdHttpRESTObserve;\n  params?: HttpParams | {\n    [param: string]: string | string[];\n  };\n  responseType?: TdHttpRESTResponseType;\n  reportProgress?: boolean;\n  withCredentials?: boolean;\n}\n\nexport interface ITdHttpRESTOptionsWithBody extends ITdHttpRESTOptions {\n  body?: any;\n}\n\nexport const NOOP_HTTP: Observable<any> = of(undefined);\n\ntype Constructor<T> = new (...args: any[]) => T;\n\n/**\n * DO NOT MODIFY\n * Taken from angular since they dont expose this function\n * This is used internally to inject services from the constructor of the base service using the mixinHttp\n * @internal\n */\nfunction injectArgs(types: (Type<any>| InjectionToken<any>| any[])[], injector: Injector): any[] {\n  const args: any[] = [];\n  for (let i: number = 0; i < types.length; i++) {\n    const arg: any = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j: number = 0; j < arg.length; j++) {\n        const meta: any = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          /* tslint:disable */\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n        /* tslint:enable */\n      }\n\n      args.push(injector.get(type !, flags));\n    } else {\n      args.push(injector.get(arg));\n    }\n  }\n  return args;\n}\n\n/** \n * Mixin to augment a service with http helpers.\n * @internal\n */\nexport function mixinHttp(base: any, config: ITdHttpRESTConfig): Constructor<any> {\n  /**\n   * Internal class used to get an instance of Injector for internal usage plus also\n   * a way to inject services from the constructor of the underlying service\n   * @internal\n   */\n  @Injectable()\n  abstract class HttpInternalClass extends base {\n    constructor(public _injector: Injector) {\n      super(...injectArgs(new ÃÂµReflectionCapabilities().parameters(base), _injector));\n      this.buildConfig();\n    }\n    abstract buildConfig(): void;\n  }\n  /**\n   * Actuall class being returned with all the hooks for http usage\n   * @internal\n   */\n  return class extends HttpInternalClass {\n    private _baseUrl: string;\n    get baseUrl(): string {\n      return (typeof(this.basePath) === 'string' ?\n        this.basePath.replace(/\\/$/, '') : '') + this._baseUrl;\n    }\n    private _baseHeaders: HttpHeaders;\n    private _defaultObserve?: TdHttpRESTObserve;\n    private _defaultResponseType?: TdHttpRESTResponseType;\n\n    http: HttpClient | HttpInterceptorService | Http;\n\n    /**\n     * Method used to setup the configuration parameters and get an instance of the http service\n     */\n    buildConfig(): void {\n      this.http = this._injector.get(config.httpServiceType || HttpClient);\n      this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\\/$/, '') : '';\n      this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new HttpHeaders();\n      this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';\n      this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';\n    }\n\n    /**\n     * Method used to build the default headers using the base headers\n     */\n    buildHeaders(): HttpHeaders {\n      let headersObj: {[key: string]: any} = {};\n      this._baseHeaders.keys().forEach((key: any) => {\n        headersObj[key] = this._baseHeaders.get(key);\n      });\n      return new HttpHeaders(headersObj);\n    }\n\n    /* tslint:disable-next-line */\n    buildRequest<Response>(method: 'POST' | 'PUT' | 'PATCH', url: string, options?: ITdHttpRESTOptionsWithBody): Observable<Response>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'POST' | 'PUT' | 'PATCH', url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<Response>(method: 'GET' | 'DELETE', url: string, options?: ITdHttpRESTOptions): Observable<Response>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'GET' | 'DELETE', url: string, options?: ITdHttpRESTOptions): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<Response>(method: TdHttpMethod, url: string, options?: ITdHttpRESTOptionsWithBody): Observable<Response>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: TdHttpMethod, url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse> {\n      return this._buildRequest(method, url, options);\n    }\n\n    /**\n     * Method used to build the request depending on the `http` service and TdHttpMethod\n     */\n    private _buildRequest(method: TdHttpMethod, url: string, options: ITdHttpRESTOptionsWithBody = {}): Observable<any> {\n      if (!options.responseType) {\n        options.responseType = this._defaultResponseType;\n      }\n      if (!options.observe) {\n        options.observe = this._defaultObserve;\n      }\n      if (!options.headers) {\n        options.headers = this.buildHeaders();\n      } else {\n        let headers: HttpHeaders = this.buildHeaders();\n        if (options.headers instanceof HttpHeaders) {\n          (<HttpHeaders>options.headers).keys().forEach((key: any) => {\n            headers = headers.set(key, (<HttpHeaders>options.headers).get(key));\n          });\n        } else {\n          for (let key in options.headers) {\n            headers = headers.set(key, <any>options.headers[key]);\n          }\n        }\n        options.headers = headers;\n      }\n      if (this.http instanceof HttpInterceptorService || this.http instanceof Http) {\n        let headers: Headers = new Headers();\n        (<HttpHeaders>options.headers).keys().forEach((key: any) => {\n          headers.set(key, (<HttpHeaders>options.headers).get(key));\n        });\n        let params: URLSearchParams = new URLSearchParams();\n        if (options.params) {\n          if (options.params instanceof HttpParams) {\n            options.params.keys().forEach((key: string) => {\n              params.set(key, (<HttpParams>options.params).get(key));\n            });\n          } else {\n            for (let key in options.params) {\n              params.set(key, <any>options.params[key]);\n            }\n          }\n        }\n        let observable: Observable<Response> = (<HttpInterceptorService>this.http).request(url, {\n          headers: headers,\n          method: method,\n          body: options.body ? options.body : undefined,\n          params: params,\n        });\n        if (options.observe === 'body') {\n          if (options.responseType === 'json') {\n            return <any>observable.pipe(\n              map((response: Response) => response.json()),\n            );\n          } else if (options.responseType === 'text') {\n            return <any>observable.pipe(\n              map((response: Response) => response.text()),\n            );\n          } else if (options.responseType === 'blob') {\n            return <any>observable.pipe(\n              map((response: Response) => response.blob()),\n            );\n          } else if (options.responseType === 'arraybuffer') {\n            return <any>observable.pipe(\n              map((response: Response) => response.arrayBuffer()),\n            );\n          }\n        } else if (options.observe === 'events') {\n          throw Error('\"events\" not suppported in @angular/http');\n        }\n        return observable;\n      } else {\n        return (<HttpClient>this.http).request(method, url, options);\n      }\n    }\n  };\n}\n","declare const Reflect: any;\nexport type TdParamType = 'param' | 'response' | 'body' | 'queryParams';\n\nexport const tdHttpRESTParam: Symbol = Symbol('TdHttpRESTParam');\n\n/**\n * Abstract implementation of the http param decorator\n * @internal\n */\nexport function TdAbstractParam(type: TdParamType, param?: string): Function {\n  return function (target: Object, propertyKey: string | symbol, parameterIndex: number): void {\n    let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyKey) || [];\n    parameters.push({\n      index: parameterIndex,\n      param: param,\n      type: type,\n    });\n    Reflect.defineMetadata(tdHttpRESTParam, parameters, target, propertyKey);\n  };\n}\n","import { HttpParams } from '@angular/common/http';\n\nimport { TdHttpMethod, ITdHttpRESTOptions, ITdHttpRESTOptionsWithBody, NOOP_HTTP } from '../../http.mixin';\nimport { TdParamType, tdHttpRESTParam } from '../params/abstract-param.decorator';\n\ndeclare const Reflect: any;\n\n/**\n * Method used to copy parameters from an array or HttpParams object\n * into a centrilized HttpParams object\n * @internal\n */\nexport function parseParams(target: HttpParams, source: HttpParams | {[key: string]: string | string[]}): HttpParams {\n  let queryParams: HttpParams = target;\n  if (source instanceof HttpParams) {\n    source.keys().forEach((key: string) => {\n      // skip if value is undefined\n      if ((<HttpParams>source).get(key) !== undefined) {\n        queryParams = queryParams.set(key, (<HttpParams>source).get(key));\n      }\n    });\n  } else {\n    for (let key in source) {\n      // skip if value is undefined\n      if (<any>source[key] !== undefined) {\n        queryParams = queryParams.set(key, <any>source[key]);\n      }\n    }\n  }\n  return queryParams;\n}\n\n/**\n * Abstract implementation of the http method decorator\n * @internal\n */\nexport function TdAbstractMethod(config: {\n  method: TdHttpMethod,\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>): any {\n    let wrappedFunction: Function = descriptor.value;\n    // replace method call with our own and proxy it\n    descriptor.value = function (): any {\n      try {\n        let replacedPath: string = config.path;\n        let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);\n        let newArgs: any[] = [];\n        let body: any;\n        let queryParams: HttpParams = new HttpParams();\n        if (parameters) {\n          // map parameters and see which type they are to act on them\n          for (let parameter of parameters) {\n            if (parameter.type === 'param') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);\n            } else if (parameter.type === 'body') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              body = arguments[parameter.index];\n            } else if (parameter.type === 'queryParams') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              let qParams: HttpParams | {[key: string]: string | string[]} = arguments[parameter.index];\n              if (config.options && config.options.params) {\n                queryParams = parseParams(queryParams, config.options.params);\n              }\n              if (qParams) {\n                queryParams = parseParams(queryParams, qParams);\n              }\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let url: string = this.baseUrl + replacedPath;\n        let options: ITdHttpRESTOptionsWithBody = Object.assign({}, config.options, {\n          body: body,\n          params: queryParams,\n        });\n        // tslint:disable-next-line\n        let request: any = this.buildRequest(config.method, url, options);\n        if (parameters) {\n          // see which one was the response parameter so we can set the request observable\n          for (let parameter of parameters) {\n            if (parameter.type === 'response') {\n              newArgs[parameter.index] = request;\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let response: any = wrappedFunction.apply(this, newArgs);\n        // if the response is NOOP_HTTP or undefined, then we return the request as it is\n        // else we return the response from the inner function\n        if (response === NOOP_HTTP || response === undefined) {\n          return request;\n        } else {\n          return response;\n        }\n      } catch (error) {\n        // tslint:disable-next-line\n        console.error(error);\n      }\n    };\n  };\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds GET request capabilities to a method\n */\nexport function GET(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'GET',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds POST request capabilities to a method\n */\nexport function POST(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'POST',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PATCH request capabilities to a method\n */\nexport function PATCH(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PATCH',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PUT request capabilities to a method\n */\nexport function PUT(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PUT',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds DELETE request capabilities to a method\n */\nexport function DELETE(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'DELETE',\n  }, config));\n}\n","import { mixinHttp, ITdHttpRESTConfig } from '../../http.mixin';\n\n/**\n * Decorator used to give a service http capabilities\n */\nexport function TdHttp(config: ITdHttpRESTConfig): Function {\n  return function <T extends { new(...args: any[]): {} }>(constructor: any): any {\n    return class extends mixinHttp(constructor, config) {\n     \n    };\n  };\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is an http parameter in a method\n */\nexport function TdParam(param: string): Function {\n  return TdAbstractParam('param', param);\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http body in a method\n */\nexport function TdBody(): Function {\n  return TdAbstractParam('body');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http response in a method\n */\nexport function TdResponse(): Function {\n  return TdAbstractParam('response');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http query parameters in a method\n */\nexport function TdQueryParams(): Function {\n  return TdAbstractParam('queryParams');\n}\n"]}